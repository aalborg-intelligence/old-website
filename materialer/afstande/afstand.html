<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>afstand – AI - Aalborg Intelligence - OLD VERSION!</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">AI - Aalborg Intelligence - OLD VERSION!</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../undervisningsforlob.html"> 
<span class="menu-text">Undervisningsforløb</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../sro.html"> 
<span class="menu-text">SRO</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../srp.html"> 
<span class="menu-text">SRP</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../materialer.html"> 
<span class="menu-text">Materialer</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../apps.html"> 
<span class="menu-text">Apps</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../referencer.html"> 
<span class="menu-text">Referencer</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Om os</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#afstande-nærmest-størst-mindst" id="toc-afstande-nærmest-størst-mindst" class="nav-link active" data-scroll-target="#afstande-nærmest-størst-mindst">Afstande, nærmest, størst, mindst</a></li>
  <li><a href="#clustering---klyngeanalyse.-skal-det-bruges" id="toc-clustering---klyngeanalyse.-skal-det-bruges" class="nav-link" data-scroll-target="#clustering---klyngeanalyse.-skal-det-bruges">Clustering - klyngeanalyse. SKAL DET BRUGES?</a>
  <ul class="collapse">
  <li><a href="#hierarkisk-clustering" id="toc-hierarkisk-clustering" class="nav-link" data-scroll-target="#hierarkisk-clustering">Hierarkisk clustering</a></li>
  <li><a href="#k-means-clustering" id="toc-k-means-clustering" class="nav-link" data-scroll-target="#k-means-clustering">k-means clustering</a></li>
  </ul></li>
  <li><a href="#clustering-og-anbefalingsalgoritmer.-det-skal-nok-ikke-bruges" id="toc-clustering-og-anbefalingsalgoritmer.-det-skal-nok-ikke-bruges" class="nav-link" data-scroll-target="#clustering-og-anbefalingsalgoritmer.-det-skal-nok-ikke-bruges">Clustering og anbefalingsalgoritmer. DET SKAL NOK IKKE BRUGES</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">




<section id="afstande-nærmest-størst-mindst" class="level1 unnumbered">
<h1 class="unnumbered">Afstande, nærmest, størst, mindst</h1>
<p>Når vi adskiller eller samler data bygger vi på en form for afstand. De <span class="math inline">\(k\)</span> <em>nærmeste</em> naboer er dem, der ligger tættest på i én eller anden forstand. Hvis det drejer sig om dem, hvis højder er tætte på hinanden eller måske dem, der vejer nogenlunde det samme, er det klart, hvad man mener. Der er tal, man umiddelbart kan sammenligne. Men hvad med at sammenligne <em>både</em> vægt og højde? Hvad betyder så mest? Er der lige langt mellem en person A, der vejer 80 kg og er 1,80 m høj og en anden, B, der vejer 90 kg og er 2,00 m eller mellem A og C, der vejer 70 kg og er 1,60 m? Det er ikke klart, selvom vi da kan plotte de tre punkter i et (vægt, højde) koordinatsystem og endda bruge Pythagoras og få den samme afstand.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> Udregner man BMI, er <span class="math inline">\(A\)</span> tættere på <span class="math inline">\(B\)</span> end på <span class="math inline">\(C\)</span>. Det kommer nok også an på, hvad vi gerne vil udtale os om: Er de nogenlunde lige gode til at løbe langt? Eller hurtigt? Mere kompliceret bliver det, hvis vi også vil inddrage øjenfarve, skostørrelse eller måske, om de køber rigtig meget mælk. Der er mange eksempler på afstande, som ikke umiddelbart er fysisk afstand. For eksempel mellem ord (LINK) eller mellem DNA (Link)</p>
</section>
<section id="clustering---klyngeanalyse.-skal-det-bruges" class="level1 unnumbered">
<h1 class="unnumbered">Clustering - klyngeanalyse. SKAL DET BRUGES?</h1>
<p>Clustering er at samle datapunkter i grupper, klynger, så objekter i en klynge har mere til fælles med hinanden end med objekter i andre grupper. Har man et afstandsbegreb, der passer godt til det, vi mener med til fælles, kan man bruge det til clustering - objekter i samme klynge er tæt på hinanden, men længere fra punkter i de andre klynger.</p>
<section id="hierarkisk-clustering" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="hierarkisk-clustering">Hierarkisk clustering</h2>
<p>Her kender vi alle parvise afstande. Og ikke andet.</p>
<p>Udfra den information laver vi et dendogram, hvor i første omgang par af datapunkter "mødes" i den højde, der svarer til deres afstand. Men der er mere: Hvornår skal datapunktet <span class="math inline">\(p\)</span> mødes med <span class="math inline">\(qr\)</span>, som mødtes tidligere? Hvornår skal <span class="math inline">\(pqr\)</span> mødes med <span class="math inline">\(ab\)</span>? Det er <em>linkage</em>-reglerne.</p>
<ul>
<li><p>Single linkage: <span class="math inline">\(pqr\)</span> mødes med <span class="math inline">\(ab\)</span> i den højde, hvor minimumsafstanden mellem de to grupper af punkter nås:<br>
Minimum af <span class="math inline">\(d(a,p),d(a,q), d(a,r), d(b,p), d(b,q), d(p,r)\)</span></p></li>
<li><p>Complete linkage: <span class="math inline">\(pqr\)</span> mødes med <span class="math inline">\(ab\)</span>, når den maksimale afstand mellem punkter i de to grupper er nået.<br>
Maksimum af <span class="math inline">\(d(a,p),d(a,q), d(a,r), d(b,p), d(b,q), d(p,r)\)</span></p></li>
<li><p>Middelafstand- average linkage: Når den gennemsnitlige afstand er nået. <span class="math inline">\(\frac{1}{2\cdot 3}(d(a,p)+d(a,q)+ d(a,r)+ d(b,p)+ d(b,q)+ d(p,r))\)</span></p></li>
</ul>
<p>(OBS: Her skal være tegninger og diagrammer -dendrogrammer. Og eksempler på, hvad forskellen er på de forskellige linkagekrav)</p>
<p>Klyngeanalyse af DNA eller for eksempel mRNA giver anledning til dendrogrammer, som kaldes de phylogenetiske træer for de arter/sygdomme,... der svarer til den analyserede DNA.</p>
<p>https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2859286/</p>
<p>https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6130602/</p>
</section>
<section id="k-means-clustering" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="k-means-clustering">k-means clustering</h2>
<p>Vores data er punkter med <span class="math inline">\(d\)</span> koordinater. Afstanden er Euklidisk. Vi vælger <span class="math inline">\(k\)</span>, det antal clusters, det skal ende med. Målet er at opdele data i <span class="math inline">\(k\)</span> dele, <span class="math inline">\(S_1, S_2,\ldots , S_k\)</span> så den samlede gennemsnitlige kvadratiske afstand <span class="math display">\[\Sigma_{i=1}^{k}\Sigma_{p,q\in S_i}\frac{1}{2|S_i|}\|p-q\|^2\]</span> indenfor de <span class="math inline">\(k\)</span> clusters er mindst mulig.</p>
</section>
</section>
<section id="clustering-og-anbefalingsalgoritmer.-det-skal-nok-ikke-bruges" class="level1 unnumbered">
<h1 class="unnumbered">Clustering og anbefalingsalgoritmer. DET SKAL NOK IKKE BRUGES</h1>
<p><em>Clustering</em> er samling af datapunkter i "klumper", hvor punkterne i en klump ligner hinanden, men ikke ligner dem, der er i andre klumper. Det kan man bruge en metrik til, men der er andre måder, data kan ligne hinanden på. Når musiktjenester anbefaler musik, online boghandlere anbefaler bøger, online supermarkeder anbefaler grønsager etc. "Andre, der hører xxx hører også yyy." "Andre, der har set filmen xxx har også set filmen yyy", så baserer de anbefalingerne på en forståelse af, hvordan vi ligner andre kunder.</p>
<p>Ligner handler her om, hvor mange film, vi har fælles med hinanden. Der er et stykke vej, til definitionen, men hold hovedet koldt, så går det:</p>
<p>Hyppige delmængder - frequent item set:</p>
<p>Hvis vi har forbrugere, der har købt/lyttet til/set som følger:</p>
<table class="caption-top table">
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">{ c,e,a}</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">{ d,b,e}</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">{ b,c,e,d}</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">{ c,e,d,a}</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">{b,e}</td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: center;">{c,d,a}</td>
</tr>
<tr class="odd">
<td style="text-align: center;">7</td>
<td style="text-align: center;">{b,e,a}</td>
</tr>
<tr class="even">
<td style="text-align: center;">8</td>
<td style="text-align: center;">{b,c}</td>
</tr>
<tr class="odd">
<td style="text-align: center;">9</td>
<td style="text-align: center;">{c,e,d}</td>
</tr>
</tbody>
</table>
<p>uddrager vi hyppige delmængder</p>
<table class="caption-top table">
<tbody>
<tr class="odd">
<td style="text-align: center;">{a}</td>
<td style="text-align: center;">hørt af 1,4,6,7</td>
</tr>
<tr class="even">
<td style="text-align: center;">{b}</td>
<td style="text-align: center;">hørt af 2,3,5,7,8</td>
</tr>
<tr class="odd">
<td style="text-align: center;">{c}</td>
<td style="text-align: center;">hørt af 1,3,4,6,8</td>
</tr>
<tr class="even">
<td style="text-align: center;">{d}</td>
<td style="text-align: center;">hørt af 2,3,4,6,8,9</td>
</tr>
<tr class="odd">
<td style="text-align: center;">{e}</td>
<td style="text-align: center;">hørt af 1,2,3,4,5,7,9</td>
</tr>
<tr class="even">
<td style="text-align: center;">{a,b}</td>
<td style="text-align: center;">hørt af 7</td>
</tr>
<tr class="odd">
<td style="text-align: center;">{a,c}</td>
<td style="text-align: center;">hørt af 1,4,6</td>
</tr>
<tr class="even">
<td style="text-align: center;">{a,d}</td>
<td style="text-align: center;">hørt af 4,6</td>
</tr>
<tr class="odd">
<td style="text-align: center;">{ a,e}</td>
<td style="text-align: center;">hørt af 1,4,7</td>
</tr>
<tr class="even">
<td style="text-align: center;">{b,c}</td>
<td style="text-align: center;">hørt af 3, 8</td>
</tr>
<tr class="odd">
<td style="text-align: center;">{b,d}</td>
<td style="text-align: center;">hørt af 2,3,8</td>
</tr>
<tr class="even">
<td style="text-align: center;">{b,e}</td>
<td style="text-align: center;">hørt af 2,3,5,7</td>
</tr>
<tr class="odd">
<td style="text-align: center;">{c,d}</td>
<td style="text-align: center;">hørt af 3,4,6,8</td>
</tr>
<tr class="even">
<td style="text-align: center;">{c,e}</td>
<td style="text-align: center;">hørt af 1,3,4</td>
</tr>
<tr class="odd">
<td style="text-align: center;">{d,e}</td>
<td style="text-align: center;">hørt af 2,3,4,9</td>
</tr>
<tr class="even">
<td style="text-align: center;">{a,c,d}</td>
<td style="text-align: center;">hørt af 4</td>
</tr>
<tr class="odd">
<td style="text-align: center;">{a,c,e}</td>
<td style="text-align: center;">hørt af 1,4</td>
</tr>
<tr class="even">
<td style="text-align: center;">{b,c,d}</td>
<td style="text-align: center;">hørt af 3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">{b,c,e}</td>
<td style="text-align: center;">hørt af 3</td>
</tr>
<tr class="even">
<td style="text-align: center;">{b,d,e}</td>
<td style="text-align: center;">hørt af 2,3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">{c,d,e}</td>
<td style="text-align: center;">hørt af 3,4,9</td>
</tr>
</tbody>
</table>
<p>Det løber ret hurtigt ud over det, man kan overskue. Men vi kan strukturere: Når {c,d,e} er set/hørt af 3,4,9 er det klart, at {c,d}, {c,e} og {d,e} også er hørt af disse og muligvis andre. Desuden synes vi nok ikke, delmængder, der kun er hørt af én, er "hyppige delmængder" og vi er ikke interesserede i delmængder med kun ét element - vi vil jo anbefale noget nyt. Vi reagerer med to tiltag:</p>
<ul>
<li><p>Vi sætter en minimal længde - lad os sige 2, så kun delmængder med mindst to elementer er med.</p></li>
<li><p>En minimal support - hvor stor en andel af lytterne skal have denne delmængde til fælles. Her vælger vi 33% - så mindst 3 skal have delmængden fælles.</p></li>
</ul>
<p>Tilbage har vi</p>
<table class="caption-top table">
<tbody>
<tr class="odd">
<td style="text-align: center;">{a,c}</td>
<td style="text-align: center;">hørt af 1,4,6</td>
</tr>
<tr class="even">
<td style="text-align: center;">{ a,e}</td>
<td style="text-align: center;">hørt af 1,4,7</td>
</tr>
<tr class="odd">
<td style="text-align: center;">{b,d}</td>
<td style="text-align: center;">hørt af 2,3,8</td>
</tr>
<tr class="even">
<td style="text-align: center;">{b,e}</td>
<td style="text-align: center;">hørt af 2,3,5,7</td>
</tr>
<tr class="odd">
<td style="text-align: center;">{c,d}</td>
<td style="text-align: center;">hørt af 3,4,6,8</td>
</tr>
<tr class="even">
<td style="text-align: center;">{c,e}</td>
<td style="text-align: center;">hørt af 1,3,4</td>
</tr>
<tr class="odd">
<td style="text-align: center;">{d,e}</td>
<td style="text-align: center;">hørt af 2,3,4,9</td>
</tr>
<tr class="even">
<td style="text-align: center;">{c,d,e}</td>
<td style="text-align: center;">hørt af 3,4,9</td>
</tr>
</tbody>
</table>
<p>Nu vender vi det lidt om og vil gruppere lytterne/seerne. Vi vil lave clustering baseret på tabellen ovenfor.</p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Afstanden bliver <span class="math inline">\(10^2+0,2^2\)</span>. Bemærk, at det er udregnet udfra vægt i kg og højde i meter. Med højde i cm ville det være <span class="math inline">\(10^2+20^2\)</span>, men stadig samme afstand fra A til B som fra A til C. Se Afstand udfra Data for mere info om effekten af at skifte enheder. Det kan godt lave om på, hvilke punkter, der ligger nærmest.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/aalborg-intelligence\.ai");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>